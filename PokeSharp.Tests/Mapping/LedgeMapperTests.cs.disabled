using Arch.Core;
using NUnit.Framework;
using PokeSharp.Core.Components.Movement;
using PokeSharp.Core.Components.Tiles;
using PokeSharp.Core.Mapping;

namespace PokeSharp.Tests.Mapping;

[TestFixture]
public class LedgeMapperTests
{
    private LedgeMapper _mapper = null!;
    private World _world = null!;

    [SetUp]
    public void Setup()
    {
        _mapper = new LedgeMapper();
        _world = World.Create();
    }

    [TearDown]
    public void TearDown()
    {
        _world.Dispose();
    }

    [Test]
    public void CanMap_WithLedgeDirection_ReturnsTrue()
    {
        // Arrange
        var props = new Dictionary<string, object>
        {
            { "ledge_direction", "down" }
        };

        // Act
        var canMap = _mapper.CanMap(props);

        // Assert
        Assert.That(canMap, Is.True);
    }

    [Test]
    public void CanMap_WithoutLedgeDirection_ReturnsFalse()
    {
        // Arrange
        var props = new Dictionary<string, object>
        {
            { "solid", true }
        };

        // Act
        var canMap = _mapper.CanMap(props);

        // Assert
        Assert.That(canMap, Is.False);
    }

    [Test]
    [TestCase("down", Direction.Down)]
    [TestCase("up", Direction.Up)]
    [TestCase("left", Direction.Left)]
    [TestCase("right", Direction.Right)]
    public void Map_ValidDirection_CreatesCorrectLedge(string directionString, Direction expectedDirection)
    {
        // Arrange
        var props = new Dictionary<string, object>
        {
            { "ledge_direction", directionString }
        };

        // Act
        var ledge = _mapper.Map(props);

        // Assert
        Assert.That(ledge.JumpDirection, Is.EqualTo(expectedDirection));
    }

    [Test]
    [TestCase("DOWN")]
    [TestCase("Up")]
    [TestCase("LeFt")]
    public void Map_CaseInsensitiveDirection_CreatesCorrectLedge(string directionString)
    {
        // Arrange
        var props = new Dictionary<string, object>
        {
            { "ledge_direction", directionString }
        };

        // Act & Assert
        Assert.DoesNotThrow(() => _mapper.Map(props));
    }

    [Test]
    public void Map_InvalidDirection_ThrowsException()
    {
        // Arrange
        var props = new Dictionary<string, object>
        {
            { "ledge_direction", "invalid" }
        };

        // Act & Assert
        var ex = Assert.Throws<InvalidOperationException>(() => _mapper.Map(props));
        Assert.That(ex!.Message, Does.Contain("Invalid ledge_direction value"));
    }

    [Test]
    public void Map_EmptyDirection_ThrowsException()
    {
        // Arrange
        var props = new Dictionary<string, object>
        {
            { "ledge_direction", "" }
        };

        // Act & Assert
        var ex = Assert.Throws<InvalidOperationException>(() => _mapper.Map(props));
        Assert.That(ex!.Message, Does.Contain("empty or whitespace"));
    }

    [Test]
    public void Map_MissingLedgeDirection_ThrowsException()
    {
        // Arrange
        var props = new Dictionary<string, object>
        {
            { "solid", true }
        };

        // Act & Assert
        Assert.Throws<InvalidOperationException>(() => _mapper.Map(props));
    }

    [Test]
    public void MapAndAdd_ValidProperties_AddsComponentToEntity()
    {
        // Arrange
        var entity = _world.Create();
        var props = new Dictionary<string, object>
        {
            { "ledge_direction", "down" }
        };

        // Act
        _mapper.MapAndAdd(_world, entity, props);

        // Assert
        Assert.That(_world.Has<TileLedge>(entity), Is.True);
        var ledge = _world.Get<TileLedge>(entity);
        Assert.That(ledge.JumpDirection, Is.EqualTo(Direction.Down));
    }

    [Test]
    public void MapAndAdd_InvalidProperties_DoesNotAddComponent()
    {
        // Arrange
        var entity = _world.Create();
        var props = new Dictionary<string, object>
        {
            { "solid", true }
        };

        // Act
        _mapper.MapAndAdd(_world, entity, props);

        // Assert
        Assert.That(_world.Has<TileLedge>(entity), Is.False);
    }

    [Test]
    public void LedgeComponent_BlocksOppositeDirection()
    {
        // Arrange
        var props = new Dictionary<string, object>
        {
            { "ledge_direction", "down" }
        };
        var ledge = _mapper.Map(props);

        // Act & Assert
        Assert.That(ledge.IsBlockedFrom(Direction.Up), Is.True, "Should block upward movement");
        Assert.That(ledge.IsBlockedFrom(Direction.Down), Is.False, "Should allow downward movement");
        Assert.That(ledge.IsBlockedFrom(Direction.Left), Is.False, "Should allow left movement");
        Assert.That(ledge.IsBlockedFrom(Direction.Right), Is.False, "Should allow right movement");
    }
}
